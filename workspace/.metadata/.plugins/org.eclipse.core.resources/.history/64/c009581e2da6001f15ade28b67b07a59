#ifndef __SETUP_INTR_C
#define __SETUP_INTR_C

#include "setup_intr.h"

void IntrHandler(void *CallBackRef, u32 Bank, u32 Status)
{
    XGpioPs *Gpio_cb = (XGpioPs *)CallBackRef;
	int cnt_anti_jitr;
	int pin_intr_stat;
	int pin_stat;
	pin_intr_stat	=	XGpioPs_IntrGetStatusPin(Gpio_cb, KEY2);
	if(pin_intr_stat==1){
		XGpioPs_IntrDisablePin(Gpio_cb, KEY2);
		// Delay
		while(cnt_anti_jitr < 100){
			pin_stat	=	XGpioPs_ReadPin(Gpio_cb, KEY2);
			if(pin_stat==1){
				cnt_anti_jitr	=	0;
			}
			else{
				++cnt_anti_jitr;
			}
		}
		// Output after delay
		pin_stat	=	XGpioPs_ReadPin(Gpio_cb, KEY2);
		if(pin_stat == 0){
			XGpioPs_WritePin(Gpio_cb, LED2, 1);
		}
		else
			XGpioPs_WritePin(Gpio_cb, LED2, 0);
		usleep(1000);
	}
	else
		return;
	XGpioPs_IntrClearPin(Gpio_cb, KEY2);
	XGpioPs_IntrEnablePin(Gpio_cb, KEY2);
}

void SetupInterruptSystem(XScuGic *GicInstancePtr, XGpioPs *Gpio, u16 GpioIntrId){
    XScuGic_Config *IntcConfig;
    // 1 exception初始化
    Xil_ExceptionInit();

    // 2 GIC初始化
    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);

    XScuGic_CfgInitialize(GicInstancePtr, IntcConfig,
                    IntcConfig->CpuBaseAddress);

    // 3 告诉exception现在需要注册的是【中断】类型的异常
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                GicInstancePtr);
    // 4 定义中断类型，GPIO类型中断；链接GPIO驱动的中断处理函数
    //      这里按理说第三个参数是XGpioPs_IntrHandler，但是代码有点问题
    //    导致不能正确执行中断。这里替换为IntrHandler可以触发。
    //    使用XGpioPsIntrhandler按理说也可以，它会在中断触发后根据有4个bank，
    //    执行4次第7步设置的Intrhandler回调函数。
    //    这里直接填Intrhandler就只执行一次，另外下面第七步的语句也没有用了。
    //    可能和中断类型是pin中断而不是bank中断有关。
    XScuGic_Connect(GicInstancePtr, GpioIntrId,
                (Xil_ExceptionHandler)XGpioPs_IntrHandler,
                (void *)Gpio);

    // 5 使能GIC
    XScuGic_Enable(GicInstancePtr, GpioIntrId);

    // 6 设置中断详细参数，哪个Device(GPIO)，哪个引脚，哪个中断触发方式
    XGpioPs_SetIntrTypePin(Gpio, KEY2,  XGPIOPS_IRQ_TYPE_EDGE_BOTH);

    // 7 设置中断处理函数(怎么和4重复了也没事？)
    // 此函数将 XGpioPs_IntrHandler（GPIO 驱动自带的中断服务函数）
    // 与实际的中断处理函数IntrHandler进行绑定，以便在 GPIO中断发生时调用后者。
    XGpioPs_SetCallbackHandler(Gpio, (void *)Gpio, IntrHandler);

    // 8 中断使能
    XGpioPs_IntrEnablePin(Gpio, KEY2);

    // 9 Exception使能
    Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ);
}


#endif
