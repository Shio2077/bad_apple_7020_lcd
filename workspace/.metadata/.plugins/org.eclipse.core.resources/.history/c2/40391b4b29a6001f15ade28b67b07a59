#ifndef __SETUP_INTR_C
#define __SETUP_INTR_C

#include "setup_intr.h"

void SetupInterruptSystem(XScuGic *GicInstancePtr, XGpioPs *Gpio, u16 GpioIntrId){
    XScuGic_Config *IntcConfig;
    // 1 exception初始化
    Xil_ExceptionInit();

    // 2 GIC初始化
    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);

    XScuGic_CfgInitialize(GicInstancePtr, IntcConfig,
                    IntcConfig->CpuBaseAddress);

    // 3 告诉exception现在需要注册的是【中断】类型的异常
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                GicInstancePtr);
    // 4 定义中断类型，GPIO类型中断；链接GPIO驱动的中断处理函数
    //      这里按理说第三个参数是XGpioPs_IntrHandler，但是代码有点问题
    //    导致不能正确执行中断。这里替换为IntrHandler可以触发。
    //    使用XGpioPsIntrhandler按理说也可以，它会在中断触发后根据有4个bank，
    //    执行4次第7步设置的Intrhandler回调函数。
    //    这里直接填Intrhandler就只执行一次，另外下面第七步的语句也没有用了。
    //    可能和中断类型是pin中断而不是bank中断有关。
    XScuGic_Connect(GicInstancePtr, GpioIntrId,
                (Xil_ExceptionHandler)XGpioPs_IntrHandler,
                (void *)Gpio);

    // 5 使能GIC
    XScuGic_Enable(GicInstancePtr, GpioIntrId);

    // 6 设置中断详细参数，哪个Device(GPIO)，哪个引脚，哪个中断触发方式
    XGpioPs_SetIntrTypePin(Gpio, KEY2,  XGPIOPS_IRQ_TYPE_EDGE_BOTH);

    // 7 设置中断处理函数(怎么和4重复了也没事？)
    // 此函数将 XGpioPs_IntrHandler（GPIO 驱动自带的中断服务函数）
    // 与实际的中断处理函数IntrHandler进行绑定，以便在 GPIO中断发生时调用后者。
    XGpioPs_SetCallbackHandler(Gpio, (void *)Gpio, IntrHandler);

    // 8 中断使能
    XGpioPs_IntrEnablePin(Gpio, KEY2);

    // 9 Exception使能
    Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ);
}

#endif
